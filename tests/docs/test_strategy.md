# タスク管理システムのテスト戦略

## 1. テスト階層

当システムでは以下の2階層のテストを採用しています：

### 単体テスト (Unit Tests)
- **目的**: コマンドライン引数の解析や基本的な入力検証など、データベースに依存しない部分をテスト
- **特徴**: 高速で軽量、外部依存がない
- **場所**: `tests/unit/` ディレクトリ

### 統合テスト (Integration Tests)
- **目的**: 実際のデータベース操作を含む機能をエンドツーエンドでテスト
- **特徴**: 一時的なデータベースを使用、実際のデータフローを検証
- **場所**: `tests/integration/` ディレクトリ

## 2. テスト方針

### 単体テスト
1. **対象**: UIレイヤー、コマンドライン引数の検証、ヘルプ表示など
2. **手法**: 依存関係が少ないためモックを最小限にする
3. **原則**: 「依存関係をモックするのが複雑になるなら、統合テストに任せる」

### 統合テスト
1. **対象**: データベースを含む機能全体
2. **手法**: 一時的なSQLiteデータベースを使用
3. **原則**: 「実際のユースケースに沿ったテストシナリオを構築する」

## 3. モックの適切な使用

### モックを使うべき場面
- 外部APIやサービスへの依存がある場合
- 時間依存の処理（現在時刻の取得など）
- ランダム性を含む処理

### モックを避けるべき場面
- データベース操作が複雑な場合（親子関係など）
- モック自体が複雑になり、メンテナンスコストが高くなる場合
- テスト対象のコードよりもモックの方が複雑になる場合

## 4. テスト実装のベストプラクティス

### 共通
- テストは独立して実行できるようにする
- テスト間の順序依存を避ける
- 適切なセットアップとクリーンアップを行う

### 単体テスト
- シンプルで読みやすいテストを心がける
- 外部依存を最小限に抑える
- モックは必要最小限にとどめる

### 統合テスト
- 実際のユースケースに沿ったシナリオをテスト
- テストデータは明示的に作成・削除する
- 適切なアサーションで結果を検証する

## 5. テスト実行

### コマンド例
```bash
# すべてのテストを実行
./run_tests.sh

# 単体テストのみ実行
./run_tests.sh unit

# 統合テストのみ実行
./run_tests.sh integration

# 特定のテストファイルを実行
./run_tests.sh tests/unit/test_objective_manual.py
```

## 6. テスト環境

### テスト用データベース
- 単体テスト: インメモリSQLite（必要に応じて）
- 統合テスト: 一時ファイルベースのSQLite

### 依存関係
- pytest: テストフレームワーク
- typer.testing.CliRunner: CLIアプリケーションのテストユーティリティ

### 設定ファイル
- conftest.py: 共通のフィクスチャ定義
- tests/unit/conftest.py: 単体テスト用の追加設定
- tests/integration/conftest.py: 統合テスト用の追加設定

## 7. 今後の改善点

### 単体テストの拡充
- コマンドライン引数のバリデーションテストを追加
- エラーケースのテストを追加

### 統合テストの拡充
- より複雑なユースケースをカバーするシナリオを追加
- エッジケースのテストを追加

### テスト環境
- CIパイプラインへの統合
- テストカバレッジの測定と監視

## 8. 結論

複雑なデータ操作を含むアプリケーションでは、単体テストと統合テストの適切なバランスが重要です。モックが複雑になる場合は、実際のデータベースを使用した統合テストの方が信頼性が高く、メンテナンスも容易です。

当プロジェクトでは、単体テストはシンプルな機能に集中し、データベース操作を含む複雑な機能は統合テストでカバーするアプローチを採用しています。これにより、テストの信頼性と保守性を高めています。 